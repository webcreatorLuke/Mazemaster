import { useState, useEffect, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, addDoc, collection, onSnapshot, query, deleteDoc, updateDoc } from 'firebase/firestore';

// Global variables provided by the Canvas environment
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Constants for cell types
const CELL_PATH = 0;
const CELL_WALL = 1;
const CELL_START = 2;
const CELL_END = 3;

// Grid dimensions
const GRID_ROWS = 15;
const GRID_COLS = 15;

// Utility function for initial grid creation
const createEmptyGrid = (rows, cols) => {
  return Array(rows).fill(0).map(() => Array(cols).fill(CELL_PATH));
};

// Main App Component
export default function App() {
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [view, setView] = useState('lobby'); // 'lobby', 'builder', 'player'
  const [selectedMaze, setSelectedMaze] = useState(null); // For editing or playing

  const [message, setMessage] = useState(''); // Global message for user feedback
  const [showMessage, setShowMessage] = useState(false);

  // Initialize Firebase and set up authentication
  useEffect(() => {
    try {
      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const firebaseAuth = getAuth(app);

      setDb(firestore);
      setAuth(firebaseAuth);

      const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
        if (user) {
          setUserId(user.uid);
          console.log("Firebase Auth State Changed: User is signed in with UID:", user.uid);
        } else {
          // If no user is signed in, try signing in with custom token or anonymously
          try {
            if (initialAuthToken) {
              await signInWithCustomToken(firebaseAuth, initialAuthToken);
              console.log("Signed in with custom token.");
            } else {
              await signInAnonymously(firebaseAuth);
              console.log("Signed in anonymously.");
            }
          } catch (error) {
            console.error("Authentication failed:", error);
            showMessageWithDelay(`Authentication failed: ${error.message}`);
          }
        }
      });
      return () => unsubscribe();
    } catch (error) {
      console.error("Failed to initialize Firebase:", error);
      showMessageWithDelay(`Failed to initialize Firebase: ${error.message}`);
    }
  }, []);

  // Function to display messages to the user
  const showMessageWithDelay = useCallback((msg, duration = 3000) => {
    setMessage(msg);
    setShowMessage(true);
    const timer = setTimeout(() => {
      setShowMessage(false);
      setMessage('');
    }, duration);
    return () => clearTimeout(timer);
  }, []);

  // Render different views based on state
  const renderView = () => {
    if (!db || !auth || !userId) {
      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-4">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
          <p className="mt-4 text-lg">Loading Firebase and authenticating...</p>
          {showMessage && (
            <div className="fixed bottom-4 left-1/2 -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-lg shadow-lg z-50">
              {message}
            </div>
          )}
        </div>
      );
    }

    return (
      <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center py-8">
        <h1 className="text-4xl font-bold mb-8 text-indigo-400">Maze Master</h1>
        <p className="text-sm mb-4 text-gray-400">Your User ID: <span className="font-mono text-blue-300 break-all">{userId}</span></p>

        {showMessage && (
          <div className="fixed bottom-4 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg z-50">
            {message}
          </div>
        )}

        {view === 'lobby' && (
          <MazeLobby
            db={db}
            userId={userId}
            setView={setView}
            setSelectedMaze={setSelectedMaze}
            showMessage={showMessageWithDelay}
          />
        )}
        {view === 'builder' && (
          <MazeBuilder
            db={db}
            userId={userId}
            setView={setView}
            selectedMaze={selectedMaze}
            setSelectedMaze={setSelectedMaze}
            showMessage={showMessageWithDelay}
          />
        )}
        {view === 'player' && selectedMaze && (
          <MazePlayer
            maze={selectedMaze}
            setView={setView}
            showMessage={showMessageWithDelay}
          />
        )}
      </div>
    );
  };

  return renderView();
}

// Maze Lobby Component
function MazeLobby({ db, userId, setView, setSelectedMaze, showMessage }) {
  const [mazes, setMazes] = useState([]);
  const [loading, setLoading] = useState(true);

  // Fetch mazes from Firestore in real-time
  useEffect(() => {
    if (!db) return;

    const mazesCollectionRef = collection(db, `artifacts/${appId}/public/data/mazes`);
    // Note: Firestore's `orderBy` can cause issues without proper indexing.
    // We will fetch all and sort in memory if needed.
    const q = query(mazesCollectionRef);

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const fetchedMazes = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setMazes(fetchedMazes);
      setLoading(false);
      console.log("Fetched mazes:", fetchedMazes);
    }, (error) => {
      console.error("Error fetching mazes:", error);
      showMessage(`Error fetching mazes: ${error.message}`);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [db, showMessage]);

  const handleCreateNew = () => {
    setSelectedMaze(null); // Clear any previously selected maze
    setView('builder');
  };

  const handlePlayMaze = (maze) => {
    setSelectedMaze(maze);
    setView('player');
  };

  const handleEditMaze = (maze) => {
    setSelectedMaze(maze);
    setView('builder');
  };

  const handleDeleteMaze = async (mazeId) => {
    if (window.confirm("Are you sure you want to delete this maze?")) { // Use window.confirm for simplicity, ideally a custom modal
      try {
        await deleteDoc(doc(db, `artifacts/${appId}/public/data/mazes`, mazeId));
        showMessage('Maze deleted successfully!');
      } catch (error) {
        console.error("Error deleting maze:", error);
        showMessage(`Error deleting maze: ${error.message}`);
      }
    }
  };

  return (
    <div className="w-full max-w-4xl p-4 bg-gray-800 rounded-lg shadow-xl">
      <h2 className="text-3xl font-bold mb-6 text-center text-blue-400">Public Mazes</h2>
      <div className="flex justify-center mb-6">
        <button
          onClick={handleCreateNew}
          className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
        >
          + Create New Maze
        </button>
      </div>

      {loading ? (
        <p className="text-center text-gray-400">Loading mazes...</p>
      ) : mazes.length === 0 ? (
        <p className="text-center text-gray-400">No mazes available. Be the first to create one!</p>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {mazes.map((maze) => (
            <div key={maze.id} className="bg-gray-700 p-4 rounded-lg shadow-md flex flex-col justify-between">
              <div>
                <h3 className="text-xl font-semibold text-white mb-2">{maze.name}</h3>
                <p className="text-sm text-gray-400 mb-3">
                  Created by: <span className="font-mono">{maze.creatorId === userId ? 'You' : maze.creatorId}</span>
                </p>
              </div>
              <div className="flex flex-wrap gap-2 mt-auto">
                <button
                  onClick={() => handlePlayMaze(maze)}
                  className="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 text-sm"
                >
                  Play
                </button>
                {maze.creatorId === userId && (
                  <>
                    <button
                      onClick={() => handleEditMaze(maze)}
                      className="flex-1 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 text-sm"
                    >
                      Edit
                    </button>
                    <button
                      onClick={() => handleDeleteMaze(maze.id)}
                      className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 text-sm"
                    >
                      Delete
                    </button>
                  </>
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

// Maze Builder Component
function MazeBuilder({ db, userId, setView, selectedMaze, setSelectedMaze, showMessage }) {
  const [grid, setGrid] = useState(createEmptyGrid(GRID_ROWS, GRID_COLS));
  const [mazeName, setMazeName] = useState('');
  const [startPoint, setStartPoint] = useState(null);
  const [endPoint, setEndPoint] = useState(null);
  const [tool, setTool] = useState(CELL_WALL); // Current drawing tool
  const [isDrawing, setIsDrawing] = useState(false); // For drag drawing

  // Load maze if editing an existing one
  useEffect(() => {
    if (selectedMaze) {
      setMazeName(selectedMaze.name);
      setGrid(JSON.parse(selectedMaze.grid));
      setStartPoint(selectedMaze.start);
      setEndPoint(selectedMaze.end);
    } else {
      // Reset for a new maze
      setMazeName('');
      setGrid(createEmptyGrid(GRID_ROWS, GRID_COLS));
      setStartPoint(null);
      setEndPoint(null);
    }
  }, [selectedMaze]);

  // Handle cell click/drag
  const handleCellAction = useCallback((row, col, currentTool) => {
    setGrid(prevGrid => {
      const newGrid = prevGrid.map(rowArr => [...rowArr]);

      // Clear existing start/end if placing a new one
      if (currentTool === CELL_START && startPoint) {
        newGrid[startPoint.y][startPoint.x] = CELL_PATH;
      }
      if (currentTool === CELL_END && endPoint) {
        newGrid[endPoint.y][endPoint.x] = CELL_PATH;
      }

      // Update the cell
      newGrid[row][col] = currentTool;

      // Update start/end points states
      if (currentTool === CELL_START) {
        setStartPoint({ x: col, y: row });
      } else if (currentTool === CELL_END) {
        setEndPoint({ x: col, y: row });
      }

      return newGrid;
    });
  }, [startPoint, endPoint]);

  const handleMouseDown = (row, col) => {
    setIsDrawing(true);
    handleCellAction(row, col, tool);
  };

  const handleMouseEnter = (row, col) => {
    if (isDrawing && (tool === CELL_WALL || tool === CELL_PATH)) { // Only drag-draw walls and paths
      handleCellAction(row, col, tool);
    }
  };

  const handleMouseUp = () => {
    setIsDrawing(false);
  };

  const handleSaveMaze = async () => {
    if (!mazeName.trim()) {
      showMessage('Please enter a name for your maze.');
      return;
    }
    if (!startPoint) {
      showMessage('Please set a start point.');
      return;
    }
    if (!endPoint) {
      showMessage('Please set an end point.');
      return;
    }

    try {
      const mazeData = {
        name: mazeName,
        creatorId: userId,
        grid: JSON.stringify(grid), // Store grid as JSON string
        start: startPoint,
        end: endPoint,
        createdAt: new Date(),
      };

      if (selectedMaze) {
        // Update existing maze
        await setDoc(doc(db, `artifacts/${appId}/public/data/mazes`, selectedMaze.id), mazeData, { merge: true });
        showMessage('Maze updated successfully!');
      } else {
        // Create new maze
        await addDoc(collection(db, `artifacts/${appId}/public/data/mazes`), mazeData);
        showMessage('Maze saved successfully!');
      }
      setSelectedMaze(null); // Clear selected maze after saving
      setView('lobby'); // Go back to lobby
    } catch (error) {
      console.error("Error saving maze:", error);
      showMessage(`Error saving maze: ${error.message}`);
    }
  };

  const getCellClassName = (cellType, row, col) => {
    let baseClasses = "w-6 h-6 sm:w-8 sm:h-8 border border-gray-600 flex items-center justify-center transition-colors duration-100 ease-in-out";
    if (cellType === CELL_PATH) return `${baseClasses} bg-gray-700 hover:bg-gray-600`;
    if (cellType === CELL_WALL) return `${baseClasses} bg-gray-400 hover:bg-gray-300`;
    if (cellType === CELL_START) return `${baseClasses} bg-green-500 hover:bg-green-400`;
    if (cellType === CELL_END) return `${baseClasses} bg-red-500 hover:bg-red-400`;
    return baseClasses;
  };

  return (
    <div className="w-full max-w-4xl p-4 bg-gray-800 rounded-lg shadow-xl">
      <h2 className="text-3xl font-bold mb-6 text-center text-yellow-400">
        {selectedMaze ? `Edit Maze: ${selectedMaze.name}` : 'Create New Maze'}
      </h2>

      <div className="mb-6 flex flex-col sm:flex-row items-center gap-4">
        <label htmlFor="mazeName" className="text-lg text-gray-300 sr-only">Maze Name:</label>
        <input
          id="mazeName"
          type="text"
          placeholder="Enter Maze Name"
          value={mazeName}
          onChange={(e) => setMazeName(e.target.value)}
          className="flex-grow p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      <div className="mb-6 flex flex-wrap justify-center gap-3">
        <button
          onClick={() => setTool(CELL_WALL)}
          className={`py-2 px-4 rounded-lg font-semibold transition duration-200 ${tool === CELL_WALL ? 'bg-gray-400 text-gray-900 shadow-md' : 'bg-gray-600 text-white hover:bg-gray-500'}`}
        >
          <i className="fas fa-hammer mr-2"></i> Draw Wall
        </button>
        <button
          onClick={() => setTool(CELL_PATH)}
          className={`py-2 px-4 rounded-lg font-semibold transition duration-200 ${tool === CELL_PATH ? 'bg-gray-700 text-gray-100 shadow-md' : 'bg-gray-600 text-white hover:bg-gray-500'}`}
        >
          <i className="fas fa-route mr-2"></i> Draw Path
        </button>
        <button
          onClick={() => setTool(CELL_START)}
          className={`py-2 px-4 rounded-lg font-semibold transition duration-200 ${tool === CELL_START ? 'bg-green-500 text-white shadow-md' : 'bg-green-700 text-white hover:bg-green-600'}`}
        >
          <i className="fas fa-flag-checkered mr-2"></i> Set Start
        </button>
        <button
          onClick={() => setTool(CELL_END)}
          className={`py-2 px-4 rounded-lg font-semibold transition duration-200 ${tool === CELL_END ? 'bg-red-500 text-white shadow-md' : 'bg-red-700 text-white hover:bg-red-600'}`}
        >
          <i className="fas fa-bullseye mr-2"></i> Set End
        </button>
      </div>

      <div
        className="grid mx-auto bg-gray-900 border-2 border-gray-700 rounded-lg overflow-hidden"
        style={{
          gridTemplateColumns: `repeat(${GRID_COLS}, minmax(0, 1fr))`,
          gridTemplateRows: `repeat(${GRID_ROWS}, minmax(0, 1fr))`,
          width: `${GRID_COLS * 32}px`, // Adjusted for sm:w-8
          maxWidth: '100%',
          aspectRatio: '1 / 1'
        }}
        onMouseLeave={handleMouseUp} // Stop drawing if mouse leaves grid
      >
        {grid.map((rowArr, rowIndex) =>
          rowArr.map((cell, colIndex) => (
            <div
              key={`${rowIndex}-${colIndex}`}
              className={getCellClassName(cell, rowIndex, colIndex)}
              onMouseDown={() => handleMouseDown(rowIndex, colIndex)}
              onMouseEnter={() => handleMouseEnter(rowIndex, colIndex)}
              onMouseUp={handleMouseUp}
            >
              {cell === CELL_START && <i className="fas fa-play text-white text-lg"></i>}
              {cell === CELL_END && <i className="fas fa-bullseye text-white text-lg"></i>}
            </div>
          ))
        )}
      </div>

      <div className="mt-8 flex justify-center gap-4">
        <button
          onClick={handleSaveMaze}
          className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-lg"
        >
          Save Maze
        </button>
        <button
          onClick={() => { setView('lobby'); setSelectedMaze(null); }}
          className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-lg"
        >
          Back to Lobby
        </button>
      </div>
       {/* Font Awesome CDN for icons */}
       <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/js/all.min.js"></script>
    </div>
  );
}

// Maze Player Component
function MazePlayer({ maze, setView, showMessage }) {
  const parsedGrid = maze ? JSON.parse(maze.grid) : createEmptyGrid(GRID_ROWS, GRID_COLS);
  const [playerPos, setPlayerPos] = useState(maze ? { x: maze.start.x, y: maze.start.y } : { x: 0, y: 0});
  const [pathVisited, setPathVisited] = useState({}); // Keep track of visited path cells
  const playerRef = useRef(null); // Ref for focusing the player div for keyboard input

  // Focus the player div on component mount for keyboard input
  useEffect(() => {
    if (playerRef.current) {
      playerRef.current.focus();
    }
  }, []);

  // Handle player movement
  const handleKeyDown = useCallback((e) => {
    let newX = playerPos.x;
    let newY = playerPos.y;

    switch (e.key) {
      case 'ArrowUp':
        newY--;
        break;
      case 'ArrowDown':
        newY++;
        break;
      case 'ArrowLeft':
        newX--;
        break;
      case 'ArrowRight':
        newX++;
        break;
      default:
        return; // Ignore other keys
    }

    // Check boundaries
    if (newX < 0 || newX >= GRID_COLS || newY < 0 || newY >= GRID_ROWS) {
      return;
    }

    // Check for wall collision
    if (parsedGrid[newY][newX] === CELL_WALL) {
      return;
    }

    setPlayerPos({ x: newX, y: newY });

    // Mark current path as visited (only if it's a path cell)
    if (parsedGrid[newY][newX] === CELL_PATH) {
      setPathVisited(prev => ({
        ...prev,
        [`${newY}-${newX}`]: true
      }));
    }

    // Check for win condition
    if (newX === maze.end.x && newY === maze.end.y) {
      showMessage('Congratulations! You reached the end of the maze!', 5000);
      setTimeout(() => setView('lobby'), 2000); // Go back to lobby after a short delay
    }
  }, [playerPos, parsedGrid, maze, setView, showMessage]);

  // Add and remove event listener for keyboard input
  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);

  const getCellClassName = (cellType, row, col) => {
    let baseClasses = "w-6 h-6 sm:w-8 sm:h-8 border border-gray-600 flex items-center justify-center";
    if (cellType === CELL_WALL) return `${baseClasses} bg-gray-400`;
    if (cellType === CELL_START) return `${baseClasses} bg-green-500`;
    if (cellType === CELL_END) return `${baseClasses} bg-red-500`;

    // Visited path cells
    if (pathVisited[`${row}-${col}`]) {
      return `${baseClasses} bg-blue-700`; // Color visited path
    }
    return `${baseClasses} bg-gray-700`; // Default path
  };

  return (
    <div className="w-full max-w-4xl p-4 bg-gray-800 rounded-lg shadow-xl" tabIndex={0} ref={playerRef}>
      <h2 className="text-3xl font-bold mb-6 text-center text-green-400">Playing: {maze.name}</h2>
      <div
        className="grid mx-auto bg-gray-900 border-2 border-gray-700 rounded-lg overflow-hidden relative"
        style={{
          gridTemplateColumns: `repeat(${GRID_COLS}, minmax(0, 1fr))`,
          gridTemplateRows: `repeat(${GRID_ROWS}, minmax(0, 1fr))`,
          width: `${GRID_COLS * 32}px`, // Adjusted for sm:w-8
          maxWidth: '100%',
          aspectRatio: '1 / 1'
        }}
      >
        {parsedGrid.map((rowArr, rowIndex) =>
          rowArr.map((cell, colIndex) => (
            <div
              key={`${rowIndex}-${colIndex}`}
              className={getCellClassName(cell, rowIndex, colIndex)}
            >
              {/* Render start/end icons even when playing */}
              {cell === CELL_START && <i className="fas fa-play text-white text-lg"></i>}
              {cell === CELL_END && <i className="fas fa-bullseye text-white text-lg"></i>}
            </div>
          ))
        )}
        {/* Player icon */}
        <div
          className="absolute bg-purple-500 rounded-full w-5 h-5 sm:w-7 sm:h-7 transition-all duration-75 ease-linear flex items-center justify-center"
          style={{
            left: `${playerPos.x * (32 / (GRID_COLS/GRID_COLS))}px`, // 32px is sm:w-8 size for grid cell
            top: `${playerPos.y * (32 / (GRID_ROWS/GRID_ROWS))}px`,
            transform: `translate(${32 / (GRID_COLS/GRID_COLS) * 0.1}px, ${32 / (GRID_ROWS/GRID_ROWS) * 0.1}px)` // Center the player icon visually within the cell
          }}
        >
          <i className="fas fa-person text-white text-sm"></i>
        </div>
      </div>

      <div className="mt-8 flex justify-center">
        <button
          onClick={() => setView('lobby')}
          className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-lg"
        >
          Back to Lobby
        </button>
      </div>
      {/* Font Awesome CDN for icons */}
      <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/js/all.min.js"></script>
    </div>
  );
}

